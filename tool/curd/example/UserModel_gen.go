// Code generated by muxi curd. DO NOT EDIT.

package model

import (
    "context"
    "encoding/json"
    "errors"
    "fmt"
    "github.com/muxi-Infra/muxi-micro/pkg/logger"
    "github.com/muxi-Infra/muxi-micro/pkg/sql"
    "golang.org/x/sync/singleflight"
    "gorm.io/gorm"
)

const (
    cacheUserUsernamePrefix = "cache:User:Username:"
    cacheUserMobilePrefix = "cache:User:Mobile:"
    cacheUserIdPrefix = "cache:User:Id:"
)

var group singleflight.Group

type UserModel interface {
    Create(ctx context.Context, data *User) error
    FindOne(ctx context.Context, id int64) (*User, error)
    FindByUsername(ctx context.Context, Username string) (*[]User, error)
    FindByMobile(ctx context.Context, Mobile string) (*[]User, error)
    Update(ctx context.Context, data *User) error
    Delete(ctx context.Context, id int64) error
}

type UserExec struct {
    exec      *sql.Execute
    cacheExec *sql.CacheExecute
    logger    logger.Logger
}

func NewUserModel(db *gorm.DB, cache *sql.CacheExecute, logger logger.Logger) *UserExec {
    exec := sql.NewExecute(User{}, db)
    return &UserExec{
        exec:      exec,
        cacheExec: cache,
        logger:    logger,
    }
}

// 序列化
func UnMarshalJSON(s string, model *User) error {
    return json.Unmarshal([]byte(s), model)
}

func UnMarshalString(s string, model *[]int64) error {
    return json.Unmarshal([]byte(s), model)
}

func (u *UserExec) Create(ctx context.Context, data *User) error {
	err := u.exec.Create(ctx, data)
	if err != nil {
		return err
	}
	go u.DelCache(ctx, data)
	return nil
}

func (u *UserExec) FindOne(ctx context.Context, Id int64) (*User, error) {
	cachestr := fmt.Sprintf("%s%v", cacheUserIdPrefix, Id)
	result, err, _ := group.Do(cachestr, func() (interface{}, error) {
		datacache := u.Get(ctx, cachestr)
		if datacache != nil {
			return datacache, nil
		}
		var data User
		u.exec.AddWhere("Id = ?", Id)
		err := u.exec.Find(ctx, &data)
		if err != nil {
			return nil, err
		}
		if data.Id == 0 {
        	return nil, DBNotFound
        }
		go u.Set(cachestr, &data)
		return &data, nil
	})
	if result == nil {
        return nil, err
    }
	return result.(*User), err
}

func (u *UserExec) FindByUsername(ctx context.Context, Username string) (*[]User, error) {
	cachestr := fmt.Sprintf("%s%v", cacheUserUsernamePrefix, Username)
	result, err, _ := group.Do(cachestr, func() (interface{}, error) {
		cacheval, err := u.cacheExec.GetCache(cachestr, ctx)
		datascache := u.GetMany(ctx, cacheval)
		if datascache != nil {
			return datascache, nil
		}
		var datas []User
		u.exec.AddWhere("Username = ?", Username)
		err = u.exec.Find(ctx, &datas)
		if err != nil {
			return nil, err
		}
		if len(datas) == 0 {
        	return nil, DBNotFound
        }
		go u.SetMany(cachestr, &datas)
		return &datas, nil
	})
	if result == nil {
    	return nil, err
    }
	return result.(*[]User), err
}

func (u *UserExec) FindByMobile(ctx context.Context, Mobile string) (*[]User, error) {
	cachestr := fmt.Sprintf("%s%v", cacheUserMobilePrefix, Mobile)
	result, err, _ := group.Do(cachestr, func() (interface{}, error) {
		cacheval, err := u.cacheExec.GetCache(cachestr, ctx)
		datascache := u.GetMany(ctx, cacheval)
		if datascache != nil {
			return datascache, nil
		}
		var datas []User
		u.exec.AddWhere("Mobile = ?", Mobile)
		err = u.exec.Find(ctx, &datas)
		if err != nil {
			return nil, err
		}
		if len(datas) == 0 {
        	return nil, DBNotFound
        }
		go u.SetMany(cachestr, &datas)
		return &datas, nil
	})
	if result == nil {
    	return nil, err
    }
	return result.(*[]User), err
}

func (u *UserExec) Update(ctx context.Context, data *User) error {
	u.exec.AddWhere("id = ?", data.Id)
	err := u.exec.Update(ctx, data)
	if err != nil {
		return err
	}
	go u.DelCache(ctx, data)
	return nil
}

func (u *UserExec) Delete(ctx context.Context, id int64) error {
	var data User
	d, err := u.FindOne(ctx, id)
	if err != nil {
		return err
	}
	data = *d
	err = u.exec.Delete(ctx, &data)
	if err != nil {
		return err
	}
	go u.DelCache(ctx, &data)
	return nil
}

// cache
func (u *UserExec) DelCache(ctx context.Context, model *User) {
	err := u.cacheExec.DeleteCache(fmt.Sprintf("%s%v", cacheUserIdPrefix, model.Id), ctx)
	if err != nil {
		u.logger.Error("Primary key cache delete failure", err)
	}
    err = u.cacheExec.DeleteCache(fmt.Sprintf("%s%v", cacheUserUsernamePrefix, model.Username), ctx)
    if err != nil {
        u.logger.Warn("Not-primary key cache delete failure", err)
    }
    err = u.cacheExec.DeleteCache(fmt.Sprintf("%s%v", cacheUserMobilePrefix, model.Mobile), ctx)
    if err != nil {
        u.logger.Warn("Not-primary key cache delete failure", err)
    }
}

func (u *UserExec) Get(ctx context.Context, cachestr string) *User {
	var data User
	cacheval, err := u.cacheExec.GetCache(cachestr, ctx)
	if err == nil {
		err := UnMarshalJSON(cacheval, &data)
		if err != nil {
			u.logger.Warn("UnMarshal failure: ", err)
			return nil
		}
		return &data
	}
	if !errors.Is(err, CacheNotFound) {
		u.logger.Warn("Primary key cache get failure: ", err)
		return nil
	}
	return nil
}

func (u *UserExec) GetMany(ctx context.Context, cachestr string) *[]User {
	var datas []User
	cacheval, err := u.cacheExec.GetCache(cachestr, ctx)
	if err == nil {
		var key []int64
		err := UnMarshalString(cacheval, &key)
		if err != nil {
			u.logger.Warn("UnMarshal failure: ", err)
			return nil
		}
		for _, c := range key {
			data, err := u.FindOne(ctx, c)
			if err != nil {
				return nil
			}
			datas = append(datas, *data)
		}
		return &datas
	}
	if !errors.Is(err, CacheNotFound) {
		u.logger.Warn("Not-primary key cache get failure: ", err)
		return nil
	}
	return nil
}

func (u *UserExec) Set(cachestr string, data *User) {
	ctx, cancel := context.WithTimeout(context.Background(), u.cacheExec.SetTTl)
	err := u.cacheExec.SetCache(cachestr, ctx, data)
	if err != nil {
		u.logger.Warn("Primary key cache set failure: ", err)
	}
	cancel()
}

func (u *UserExec) SetMany(cachestr string, data *[]User) {
	ctx, cancel := context.WithTimeout(context.Background(), u.cacheExec.SetTTl)
	var key []int64
	for _, v := range *data {
		key = append(key, v.Id)
		cachestr := fmt.Sprintf("%s%v", cacheUserIdPrefix, v.Id)
		u.Set(cachestr, &v)
	}
	err := u.cacheExec.SetCache(cachestr, ctx, &key)
	if err != nil {
		u.logger.Warn("Not-primary key cache set failure: ", err)
	}
	cancel()
}